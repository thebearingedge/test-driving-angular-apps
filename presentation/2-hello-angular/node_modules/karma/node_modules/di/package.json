{
  "name": "di",
  "version": "0.0.1",
  "description": "Dependency Injection for Node.js. Heavily inspired by AngularJS.",
  "main": "lib/index.js",
  "scripts": {
    "test": "mocha --compilers coffee:coffee-script test/*"
  },
  "repository": {
    "type": "git",
    "url": "git://github.com/vojtajina/node-di.git"
  },
  "keywords": [
    "di",
    "dependency",
    "injection",
    "injector"
  ],
  "devDependencies": {
    "grunt": "~0.4",
    "grunt-simple-mocha": "~0.4",
    "grunt-contrib-jshint": "~0.6",
    "mocha": "~1.12",
    "chai": "~1.7",
    "coffee-script": "~1.6"
  },
  "author": {
    "name": "Vojta Jina",
    "email": "vojta.jina@gmail.com"
  },
  "license": "MIT",
  "readme": "#### THIS PROJECT IS DEPRECATED, please consider using [angular/di](https://github.com/angular/di.js) instead.\nI don't actively maintain this project, in favor of angular/di, which is heavily influenced by node-di and thus the migration should be easy. Eventually angular/di will be published to NPM as di@2.0.\n\n---------\n\n## Dependency Injection framework for Node.js\n\n### Why Dependency Injection ?\nThere are two things - **Dependency Injection pattern** (aka Inversion of Control) and **Dependency Injection framework**.\n\nThe Dependency Injection pattern is about separating the instantiation of objects from the actual logic and behavior that they encapsulate. This pattern has many benefits such as:\n\n- **explicit dependencies** - all dependencies are passed in as constructor arguments, which makes it easy to understand how particular object depends on the rest of the environment,\n- **code reuse** - such an object is much easier to reuse in other environments, because it is not coupled to a specific implementation of its dependencies,\n- and **much easier to test**, because testing is essentially about instantiating a single object without the rest of the environment.\n\nFollowing this pattern is, of course, possible without any framework.\n\nHowever, if you do follow the Dependency Injection pattern, you typically end up with some kind of nasty `main()` method, where you instantiate all the objects and wire them together. The Dependency Injection framework saves you from this boilerplate. **It makes wiring the application declarative rather than imperative.** Each component declares its dependencies and the framework does transitively resolve these dependencies...\n\n\n### Example\n\n```js\nvar Car = function(engine) {\n  this.start = function() {\n    engine.start();\n  };\n};\n\nvar createPetrolEngine = function(power) {\n  return {\n    start: function() {\n      console.log('Starting engine with ' + power + 'hp');\n    }\n  };\n};\n\n\n// a module is just a plain JavaScript object\n// it is a recipe for the injector, how to instantiate stuff\nvar module = {\n  // if an object asks for 'car', the injector will call new Car(...) to produce it\n  'car': ['type', Car],\n  // if an object asks for 'engine', the injector will call createPetrolEngine(...) to produce it\n  'engine': ['factory', createPetrolEngine],\n  // if an object asks for 'power', the injector will give it number 1184\n  'power': ['value', 1184] // probably Bugatti Veyron\n};\n\n\nvar di = require('di');\nvar injector = new di.Injector(module);\n\ninjector.invoke(function(car) {\n  car.start();\n});\n```\nFor more examples, check out [the tests](test/injector.spec.coffee). You can also check out [Karma](https://github.com/karma-runner/karma) and its plugins for more complex examples.\n\n\n### Registering stuff\n\n#### type(token, Constructor)\nTo produce the instance, `Constructor` will be called with `new` operator.\n```js\nvar module = {\n  'engine': ['type', DieselEngine]\n};\n```\n\n#### factory(token, factoryFn)\nTo produce the instance, `factoryFn` will be called (without any context) and its result will be used.\n```js\nvar module = {\n  'engine': ['factory', createDieselEngine]\n};\n```\n\n#### value(token, value)\nRegister the final value.\n```js\nvar module = {\n  'power': ['value', 1184]\n};\n```\n\n\n### Annotation\nThe injector looks up tokens based on argument names:\n```js\nvar Car = function(engine, license) {\n  // will inject objects bound to 'engine' and 'license' tokens\n};\n```\n\nYou can also use comments:\n```js\nvar Car = function(/* engine */ e, /* x._weird */ x) {\n  // will inject objects bound to 'engine' and 'x._weird' tokens\n};\n```\n\nSometimes it is helpful to inject only a specific property of some object:\n```js\nvar Engine = function(/* config.engine.power */ power) {\n  // will inject 1184 (config.engine.power),\n  // assuming there is no direct binding for 'config.engine.power' token\n};\n\nvar module = {\n  'config': ['value', {engine: {power: 1184}, other : {}}]\n};\n```\n\n### Differences to Angular's DI\n\n- no config/runtime phases (configuration happens by injecting a config object)\n- no global module register\n- no array annotations (comments annotations instead)\n- comment annotation\n- no decorators (maybe not yet?)\n- service -> type\n- child injectors\n- private modules\n\n\n---------\nMade for [Karma]. Heavily influenced by [AngularJS]. Also inspired by [Guice] and [Pico Container].\n\n[AngularJS]: http://angularjs.org/\n[Pico Container]: http://picocontainer.codehaus.org/\n[Guice]: http://code.google.com/p/google-guice/\n[Karma]: http://karma-runner.github.io/\n\n\n<!--\nObject - a member of object graph in an application that can have dependencies on instances of other types (i.e. other Objects).\nToken - each Object dependency (not an Object itself) is identified via a Token. Token is typically an annotation, string constant or a class/type\nInjector - a container or context, capable of resolving Object dependencies and caching references to Objects constructed during the dependency resolution process.\nProvider - a recipe for constructing Objects, typically a constructor or factory function\nBinding - a mapping between a Token and a Provider\nModule - a set of bindings. A Module is used to configure an Injector and defines which Objects can be resolved via an Injector. Module can also be used to override Object definitions (for reconfiguration or mocking purposes). \n-->\n",
  "readmeFilename": "README.md",
  "bugs": {
    "url": "https://github.com/vojtajina/node-di/issues"
  },
  "homepage": "https://github.com/vojtajina/node-di",
  "_id": "di@0.0.1",
  "_from": "di@~0.0.1"
}
